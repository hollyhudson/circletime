var Napchart =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {


var registered = []

module.exports = {
  string: function (text, x, y, style) {
		// used for adding text strings to the system

		// check if there is a duplicate
    var duplicate = registered.some(function (string) {
      return (
				string.text == text &&
				string.x == x &&
				string.y == y
      )
    })

    if (duplicate) {
      return
    }

    registered.push({
      text: text,
      x: x,
      y: y,
      style: style || {},
      id: registered.length
    })
  },

  writeAll: function (chart) {
		// will calculate position and write all registered elements
		// console.log(registered)
    var ctx = chart.ctx
    var helpers = chart.helpers
    var config = chart.config

		// measure and find corner positions for all elements
    registered.forEach(function (string) {
      var fontSize = string.style.size || config.fontSize
      ctx.font = helpers.fontSize(chart, fontSize)

      var width = ctx.measureText(string.text).width
      var height = fontSize

      if (string.style.background) {
        width += config.content.textBoxPadWidth
        height *= 1.8
      }

      string.corners = [
        {
          x: string.x - width / 2,
          y: string.y + height / 2
        },
        {
          x: string.x + width / 2,
          y: string.y + height / 2
        },
        {
          x: string.x + width / 2,
          y: string.y - height / 2
        },
        {
          x: string.x - width / 2,
          y: string.y - height / 2
        }
      ]
    })

    registered.forEach(function (string, i) {
      if (i > 1) {
				// return
      }
      var collidesWithMe = registered.filter(function (foreignString, i) {
        return string.corners.some(function (corner) {
          if (isPointInsideRectangle(corner, foreignString.corners)) {
						// console.log(string.text, 'collides with', foreignString.text)
            var fixedElements = fixCollision(string, foreignString)
            string = fixedElements.a
            foreignString = fixedElements.b

            return true
          }
          return false
        })
      })
    })

		// collision fix
    function fixCollision (a, b) {
			// returns new corners

			// how much is it overlapping?
      var overlapX = a.corners[1].x - b.corners[0].x
      var overlapY = a.corners[1].y - b.corners[3].y
			// move shortest
      if (overlapX < overlapY) {
        a.corners = translate(a.corners, {
          x: -overlapX / 2,
          y: 0
        })
        a.x -= overlapX / 2
        b.corners = translate(b.corners, {
          x: overlapX / 2,
          y: 0
        })
        b.x += overlapX / 2
      } else {
        a.corners = translate(a.corners, {
          x: 0,
          y: -overlapY / 2
        })
        a.y -= overlapY / 2
        b.corners = translate(b.corners, {
          x: 0,
          y: overlapY / 2
        })
        b.y += overlapY / 2
      }
      return ({a: a, b: b})
    }

		// actual drawing
    registered.forEach(function (string) {
      var fontSize = string.style.size || config.fontSize
      ctx.font = helpers.fontSize(chart, fontSize)

			// background
      if (string.style.background) {
        ctx.save()
        var width = ctx.measureText(string.text).width + config.content.textBoxPadWidth
        var height = fontSize * 1.8
        ctx.fillStyle = string.style.background
        ctx.globalAlpha = 0.7
        if (string.style.roundedCorners) {
          helpers.fillRectRounded(chart, string.corners[3].x, string.corners[3].y, width, height)
        } else {
          ctx.fillRect(string.corners[3].x, string.corners[3].y, width, height)
        }
        ctx.restore()
      }

			// text
      ctx.fillStyle = string.style.color || config.fontColor
      ctx.fillText(string.text, string.x, string.y)
    })

    registered = []
  }
}

function isPointInsideRectangle (point, rectangle) {
  if (point.x > rectangle[0].x &&
		point.x < rectangle[1].x &&
		point.y < rectangle[0].y &&
		point.y > rectangle[2].y
		) {
    return true
  }
  return false
}

function translate (corners, values) {
  return corners.map(function (c) {
    return {
      x: c.x + values.x,
      y: c.y + values.y
    }
  })
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

/**
 *
 * function calculateShape
 *
 * This function takes a normal shape definition object
 * and calculates positions and sizes
 *
 * Returns a more detailed shape object that is later
 * assigned to chart.shape and used when drawing
 *
 */

module.exports = function calculateShape(chart, shape) {
  // apply defaults
  var shape = Object.assign({}, shape)

  /**
   * Find out totalRadians
   * This be 2 * PI if the shape is circular
   */

  var totalRadians = 0
  shape.elements.forEach(function (element) {
    if (element.type === 'arc') {
      totalRadians += element.radians
    }
  })

  /**
   * Is shape continous?
   * TODO:Maybe we should keep this config in the shape object somehow
   */
  if (totalRadians == 2 * Math.PI) {
    chart.shapeIsContinous = true
  } else {
    chart.shapeIsContinous = false
  }

  /**
   * Find out angle of shapes
   */

  shape.elements.forEach(function (element, i) {
    if (i === 0) { element.startAngle = 0 }
    else { element.startAngle = shape.elements[i - 1].endAngle }

    if (element.type === 'arc') {
      element.endAngle = element.startAngle + element.radians
    } else if (element.type === 'line') {
      element.endAngle = element.startAngle
    }
  })

  /**
   * Find out length of the shapes
   *
   * Perimeter of circle = 2 * radius * PI
   */

  // how much space do we have for lines?
  var space = chart.w
  // paddings
  space -= 120

  // arcs
  shape.elements.forEach(function (element, i) {
    if (element.type === 'arc') {
      space -= (chart.config.edgeRadius * (element.radians / Math.PI))
    }
  })

  if (space < 0) {
    space = 0
  }

  var totalLength = 0
  shape.elements.forEach(function (element, i) {
    if (element.type === 'arc') {
      element.length = element.radians * chart.config.baseRadius
    } else if (element.type === 'line') {
      element.length = space * (element.percent / 100)
    }

    element.length = Math.round(element.length)
    totalLength += element.length
  })

  /**
   * Calculate how many minutes each element should get
   */

  var totalMinutes = 0
  shape.elements.forEach(function (element, i) {
    element.minutes = Math.floor((element.length / totalLength) * 1440)
    totalMinutes += element.minutes
    if (i == shape.elements.length - 1 && totalMinutes < 1440) {
      totalMinutes -= element.minutes
      element.minutes = 1440 - totalMinutes
      totalMinutes += element.minutes
    }
  })

  if (totalMinutes != 1440) {
    console.warn('bad things might happen')
  }

  /**
   * Delete elements that have 0 minutes
   */

  shape.elements = shape.elements.filter(function (element) { return element.minutes > 0; })

  /**
   * Ok, so totalMinutes is now 1440
   * Now we need to create a .start and .end point on all
   * the shape elements
   */

  shape.elements.forEach(function (element, i) {
    if (i === 0) { element.start = shape.shift }
    else if (i > 0) { element.start = shape.elements[i - 1].end }
    element.end = chart.helpers.limit(element.start + element.minutes)
  })

  /**
   * Calculate startPoints and endPoints
   * First point is center
   * The point only changes on line-segments
   */

  var center = {
    x: chart.w / 2,
    y: chart.h / 2
  }
  shape.elements.forEach(function (element, i) {
    if (i === 0) {
      element.startPoint = center
      element.endPoint = center
    } else if (element.type === 'arc') {
      element.startPoint = shape.elements[i - 1].endPoint
      element.endPoint = shape.elements[i - 1].endPoint
    } else if (element.type === 'line') {
      element.startPoint = shape.elements[i - 1].endPoint
    }
    if (element.type === 'line') {
      element.endPoint = {
        x: element.startPoint.x + Math.cos(element.startAngle) * element.length,
        y: element.startPoint.y + Math.sin(element.startAngle) * element.length
      }
    }
  })

  /**
   * Center the shape
   */

  var limits = {}

  function pushLimits(point) {
    if (Object.keys(limits).length === 0) {
      limits = {
        up: point.y,
        down: point.y,
        left: point.x,
        right: point.x
      }
    } else {
      if (point.y < limits.up) { limits.up = point.y }
      if (point.y > limits.down) { limits.down = point.y }
      if (point.x < limits.left) { limits.left = point.x }
      if (point.x > limits.right) { limits.right = point.x }
    }
  }
  shape.elements.forEach(function (element, i) {
    pushLimits(element.startPoint)
    pushLimits(element.endPoint)
  })

  // we need to know the distances to the edge of the canvas
  limits.down = chart.h - limits.down
  limits.right = chart.w - limits.right

  // the distances should be equal, therefore, shift the points
  // if it is not
  var shiftLeft = (limits.left - limits.right) / 2
  var shiftUp = (limits.up - limits.down) / 2

  // apply shiftDown setting from shape (useful for line shape)
  shiftUp = shiftUp - shape.shiftDown * chart.ratio

  shape.elements.forEach(function (element, i) {
    element.startPoint = {
      x: element.startPoint.x - shiftLeft,
      y: element.startPoint.y - shiftUp
    }
    element.endPoint = {
      x: element.endPoint.x - shiftLeft,
      y: element.endPoint.y - shiftUp
    }
  })

  // create lanes based on how many
  shape.lanes = []
  var lanes = chart.data.lanes
  console.log(lanes)
  if (typeof lanes == 'undefined' || lanes == 0) {
    console.error("chart.data.lanes is undefined, not an array OR HAS 0 ELEMENTS:", chart.data.lanes)
  }
  var maxLaneSize = shape.maxLaneSize * chart.ratio
  var laneMaxRadius = shape.laneMaxRadius * chart.ratio
  var laneMinRadius = shape.laneMinRadius * chart.ratio
  var spaceForLanes = laneMaxRadius - laneMinRadius
  var sizeEachLane = Math.min(maxLaneSize, spaceForLanes / lanes)
  var marginRadius = ((spaceForLanes - sizeEachLane * lanes)) + laneMinRadius
  for (var i = 0; i < lanes; i++) {
    shape.lanes.push({
      start: marginRadius + sizeEachLane * i,
      end: marginRadius + sizeEachLane * (i + 1)
    })
  }

  return shape
}

function scaleConfig(config, ratio) {
  function scaleFn(base, value, key) {
    if (value > 1 || value < 1 || value === 1) { // if value is a number
      base[key] = value * ratio
    }
  }
  helpers.deepEach(config, scaleFn)
  return config
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var Napchart = {}

/* helper functions */
__webpack_require__(3)(Napchart)
__webpack_require__(4)(Napchart)
__webpack_require__(5)(Napchart)

/* config file */
__webpack_require__(6)(Napchart)

/* core and init */
__webpack_require__(7)(Napchart)

/* drawing */
__webpack_require__(8)(Napchart)
__webpack_require__(11)(Napchart)

/* interaction */
__webpack_require__(25)(Napchart)

/* history */
__webpack_require__(28)(Napchart)

module.exports = Napchart

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* global window: false */
/* global document: false */


module.exports = function (Chart) {
  // Global Chart helpers object for utility methods and classes
  var helpers = Chart.helpers = {}

  helpers.duration = function (start, end) {
    return helpers.limit(end - start)
  }

  helpers.range = function (a, b, anticlockwise) {
    // kinda same as duration, but only when !anticlockwise
    if (anticlockwise) {
      return helpers.limit(a - b)
    } else {
      return helpers.limit(b - a)
    }
  }

  helpers.minutesToHoursMinutes = function (min) {
    var hours = Math.floor(min / 60) + ''
    var minutes = min % 60 + ''
    minutes = Math.floor(minutes)

    return {
      hours: hours,
      minutes: minutes
    }
  }

  helpers.minutesToReadable = function (min, breakpoint) {
    // extends minutesToHoursMinutes and adds h and m
    var hm
    if (typeof breakpoint === 'undefined') {
      breakpoint = 60
    }

    if (min > breakpoint) {
      hm = helpers.minutesToHoursMinutes(min)
      return hm.hours + 'h ' + hm.minutes + 'm'
    } else {
      return min + 'm'
    }
  }

  helpers.middlePoint = function (start, end) {
    var duration = helpers.duration(start, end)
    return helpers.limit(start + duration / 2)
  }

  helpers.getProgressBetweenTwoValues = function (pos, start, end) {
    var result = helpers.duration(start, pos) / helpers.duration(start, end)
    if (isNaN(result)) {
      // I am doing this check because when dividing 0/0 it outputs NaN
      return 1
    } else {
      return result
    }
  }

  helpers.getPositionBetweenTwoValues = helpers.getProgressBetweenTwoValues

  helpers.limit = function (value) {
    if (value == 1440) { return 1440 }
    return value - 1440 * Math.floor(value / 1440)
  }

  helpers.shortestWay = function (a) {
    // alternative??console.log(a - 1440 * Math.floor(a/720))

    // 1440/2 = 720
    if (a > 720) {
      return a - 1440
    } else if (a < -720) {
      return a + 1440
    } else {
      return a
    }
  }

  helpers.minutesDistance = function (a, b) {
    return Math.min(helpers.duration(a, b), helpers.duration(b, a))
  }

  helpers.isInside = function (point, start, end) {
    if (end > start) {
      if (point < end && point > start) {
        return true
      }
    } else if (start > end) {
      if (point > start || point < end) {
        return true
      }
    }
    if (point == start || point == end) {
      return true
    }
    return false
  }

  helpers.isInsideAngle = function (point, start, end) {
    // same as angle but it limits values to between 0 and 2*Math.PI
    return helpers.isInside(limit(point), limit(start), limit(end))

    function limit(angle) {
      angle %= Math.PI * 2
      if (angle < 0) {
        angle += Math.PI * 2
      }
      return angle
    }
  }

  helpers.distance = function (x, y, a) {
    var y = a.y - y
    var x = a.x - x
    return Math.sqrt(y * y + x * x)
  }

  helpers.angleBetweenTwoPoints = function (x, y, a) {
    var distance = helpers.distance(x, y, a)
    var y = (a.y - y) / distance
    var x = (a.x - x) / distance

    var angle = Math.atan(y / x)
    if (x >= 0) {
      angle += Math.PI
    }
    angle += Math.PI / 2
    return angle
  }

  helpers.minutesToClock = function (chart, minutes) {
    minutes = Math.floor(minutes)
    var hours = Math.floor(minutes / 60) + ''
    minutes = minutes % 60 + ''
    if (hours.length == 1) {
      hours = '0' + hours
    }
    if (minutes.length == 1) {
      minutes = '0' + minutes
    }
  
    if (chart.config.ampm) {

      if (minutes == 0 && hours % 12 === 0) {
        return (hours > 12 || hours == 0) ? 'midnight' : 'noon'
      }
      return (((hours*1 + 11) % 12) + 1) + ':' + minutes + ((hours < 12) ? ' am' : ' pm')

    } else {
      return hours + ':' + minutes
    }
  }

  // helpers.XYtoMinutes = function (x,y) {
  //   minutes = (Math.atan(y /x) / (Math.PI * 2)) * 1440 + 360;
  //   if (x < 0) {
  //       minutes += 720;
  //   }
  //   minutes = Math.round(minutes);

  //   return minutes;
  // };

  helpers.distanceFromPointToLineSegment = function (x, y, a, b) {
    var x1 = a.x
    var y1 = a.y
    var x2 = b.x
    var y2 = b.y

    var A = x - x1
    var B = y - y1
    var C = x2 - x1
    var D = y2 - y1

    var dot = A * C + B * D
    var len_sq = C * C + D * D
    var param = -1
    if (len_sq != 0) // in case of 0 length line
    {
      param = dot / len_sq
    }

    var xx, yy

    if (param < 0) {
      xx = x1
      yy = y1
    } else if (param > 1) {
      xx = x2
      yy = y2
    } else {
      xx = x1 + param * C
      yy = y1 + param * D
    }

    var dx = x - xx
    var dy = y - yy
    return Math.sqrt(dx * dx + dy * dy)
  }

  helpers.distanceFromPointToLine = function (y, lineY) {
    //// NBNB very simplified function for only horizontal lines
    return lineY - y
  }

  helpers.each = function (loopable, callback, self, reverse) {
    // Check to see if null or undefined firstly.
    var i, len
    if (helpers.isArray(loopable)) {
      len = loopable.length
      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          callback.call(self, loopable[i], i)
        }
      } else {
        for (i = 0; i < len; i++) {
          callback.call(self, loopable[i], i)
        }
      }
    } else if (typeof loopable === 'object') {
      var keys = Object.keys(loopable)
      len = keys.length
      for (i = 0; i < len; i++) {
        callback.call(self, loopable[keys[i]], keys[i])
      }
    }
  }

  helpers.deepEach = function (loopable, callback) {
    // Check to see if null or undefined firstly.
    var i, len

    function search(loopable, cb) {
      if (helpers.isArray(loopable)) {
        for (var i = 0; i < loopable.length; i++) {
          cb(loopable, loopable[i], i)
        }
      } else if (typeof loopable === 'object') {
        var keys = Object.keys(loopable)
        for (var i = 0; i < keys.length; i++) {
          cb(loopable, loopable[keys[i]], keys[i])
        }
      }
    }

    function found(base, value, key) {
      if (helpers.isArray(value) || typeof value === 'object') {
        search(value, found)
      } else {
        callback(base, value, key)
      }
    }

    search(loopable, found)
  }

  helpers.clone = function (obj) {
    return JSON.parse(JSON.stringify(obj))
  }

  helpers.extend = function (base) {
    var arguments$1 = arguments;

    var setFn = function (value, key) {
      base[key] = value
    }
    for (var i = 1, ilen = arguments.length; i < ilen; i++) {
      helpers.each(arguments$1[i], setFn)
    }
    return base
  }

  helpers.uid = (function () {
    var id = 0
    return function () {
      return id++
    }
  }())

  var easingEffects = helpers.easingEffects = {
    linear: function (t) {
      return t
    },
    easeInQuad: function (t) {
      return t * t
    },
    easeOutQuad: function (t) {
      return -1 * t * (t - 2)
    },
    easeInOutQuad: function (t) {
      if ((t /= 1 / 2) < 1) {
        return 1 / 2 * t * t
      }
      return -1 / 2 * ((--t) * (t - 2) - 1)
    },
    easeInCubic: function (t) {
      return t * t * t
    },
    easeOutCubic: function (t) {
      return 1 * ((t = t / 1 - 1) * t * t + 1)
    },
    easeInOutCubic: function (t) {
      if ((t /= 1 / 2) < 1) {
        return 1 / 2 * t * t * t
      }
      return 1 / 2 * ((t -= 2) * t * t + 2)
    },
    easeInQuart: function (t) {
      return t * t * t * t
    },
    easeOutQuart: function (t) {
      return -1 * ((t = t / 1 - 1) * t * t * t - 1)
    },
    easeInOutQuart: function (t) {
      if ((t /= 1 / 2) < 1) {
        return 1 / 2 * t * t * t * t
      }
      return -1 / 2 * ((t -= 2) * t * t * t - 2)
    },
    easeInQuint: function (t) {
      return 1 * (t /= 1) * t * t * t * t
    },
    easeOutQuint: function (t) {
      return 1 * ((t = t / 1 - 1) * t * t * t * t + 1)
    },
    easeInOutQuint: function (t) {
      if ((t /= 1 / 2) < 1) {
        return 1 / 2 * t * t * t * t * t
      }
      return 1 / 2 * ((t -= 2) * t * t * t * t + 2)
    },
    easeInSine: function (t) {
      return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1
    },
    easeOutSine: function (t) {
      return 1 * Math.sin(t / 1 * (Math.PI / 2))
    },
    easeInOutSine: function (t) {
      return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1)
    },
    easeInExpo: function (t) {
      return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1))
    },
    easeOutExpo: function (t) {
      return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1)
    },
    easeInOutExpo: function (t) {
      if (t === 0) {
        return 0
      }
      if (t === 1) {
        return 1
      }
      if ((t /= 1 / 2) < 1) {
        return 1 / 2 * Math.pow(2, 10 * (t - 1))
      }
      return 1 / 2 * (-Math.pow(2, -10 * --t) + 2)
    },
    easeInCirc: function (t) {
      if (t >= 1) {
        return t
      }
      return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1)
    },
    easeOutCirc: function (t) {
      return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t)
    },
    easeInOutCirc: function (t) {
      if ((t /= 1 / 2) < 1) {
        return -1 / 2 * (Math.sqrt(1 - t * t) - 1)
      }
      return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1)
    },
    easeInElastic: function (t) {
      var s = 1.70158
      var p = 0
      var a = 1
      if (t === 0) {
        return 0
      }
      if ((t /= 1) === 1) {
        return 1
      }
      if (!p) {
        p = 1 * 0.3
      }
      if (a < Math.abs(1)) {
        a = 1
        s = p / 4
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a)
      }
      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p))
    },
    easeOutElastic: function (t) {
      var s = 1.70158
      var p = 0
      var a = 1
      if (t === 0) {
        return 0
      }
      if ((t /= 1) === 1) {
        return 1
      }
      if (!p) {
        p = 1 * 0.3
      }
      if (a < Math.abs(1)) {
        a = 1
        s = p / 4
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a)
      }
      return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1
    },
    easeInOutElastic: function (t) {
      var s = 1.70158
      var p = 0
      var a = 1
      if (t === 0) {
        return 0
      }
      if ((t /= 1 / 2) === 2) {
        return 1
      }
      if (!p) {
        p = 1 * (0.3 * 1.5)
      }
      if (a < Math.abs(1)) {
        a = 1
        s = p / 4
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a)
      }
      if (t < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p))
      }
      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1
    },
    easeInBack: function (t) {
      var s = 1.70158
      return 1 * (t /= 1) * t * ((s + 1) * t - s)
    },
    easeOutBack: function (t) {
      var s = 1.70158
      return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1)
    },
    easeInOutBack: function (t) {
      var s = 1.70158
      if ((t /= 1 / 2) < 1) {
        return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s))
      }
      return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2)
    },
    easeInBounce: function (t) {
      return 1 - easingEffects.easeOutBounce(1 - t)
    },
    easeOutBounce: function (t) {
      if ((t /= 1) < (1 / 2.75)) {
        return 1 * (7.5625 * t * t)
      } else if (t < (2 / 2.75)) {
        return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75)
      } else if (t < (2.5 / 2.75)) {
        return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375)
      }
      return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375)
    },
    easeInOutBounce: function (t) {
      if (t < 1 / 2) {
        return easingEffects.easeInBounce(t * 2) * 0.5
      }
      return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5
    }
  }

  helpers.isArray = Array.isArray ?
    function (obj) {
      return Array.isArray(obj)
    } :
    function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]'
    }
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {


module.exports = function (Napchart) {
  var helpers = Napchart.helpers

  helpers.strokeSegment = function (chart, start, end, config) {
  	var ctx = chart.ctx
  	ctx.save()
  	ctx.strokeStyle = config.color
  	ctx.lineWidth = chart.config.bars.general.stroke.lineWidth
  	ctx.lineJoin = 'mittel'

  	helpers.createSegment(chart, config.outerRadius, config.innerRadius, start, end)

  	ctx.stroke()
  	ctx.restore()
  }

  helpers.colorMap = function(chart, color) {
    if(color.includes('#')){
      return color
    } else {
      return chart.config.colorMap[color]
    }
  }

  helpers.fillRectRounded = function (chart, x, y, width, height) {
    var cornerRadius = chart.config.cornerRadius
    var ctx = chart.ctx
    ctx.save()

    // stroke edges give rounded effect
    ctx.strokeStyle = ctx.fillStyle
    ctx.lineJoin = 'round'
    ctx.lineWidth = cornerRadius
    ctx.strokeRect(x + (cornerRadius / 2), y + (cornerRadius / 2), width - cornerRadius, height - cornerRadius)

    ctx.restore()
  }

  helpers.circle = function (chart, point, radius) {
    var ctx = chart.ctx
    ctx.beginPath()
    ctx.arc(point.x, point.y, radius, 0, Math.PI * 2)
    ctx.closePath()
  }

  helpers.fillCircle = function (chart, point, radius) {
    var ctx = chart.ctx
    this.circle(chart, point, radius)
    ctx.fill()
  }

  helpers.fontSize = function (chart, size) {
    var base = chart.config.baseFontSize.split(':')[1]
    size = base * size
    return (size + "px " + (chart.config.font))
  }
}


/***/ }),
/* 5 */
/***/ (function(module, exports) {


module.exports = function (Napchart) {
  var helpers = Napchart.helpers

  helpers.XYtoInfo = function (chart, x, y) {
    // will gather three things: minutes and distance and lane from basepoint
    var minutes, distance
    var shape = chart.shape

    // which element is the right sector

    var shapeElement = shape.elements.find(function (element) {
      if (element.type === 'arc') {
        var angle = helpers.angleBetweenTwoPoints(x, y, element.startPoint)
        if (angle >= element.startAngle && angle <= element.endAngle) {
          return true
        }
      } else if (element.type === 'line') {
        var angle1 = helpers.angleBetweenTwoPoints(x, y, element.startPoint)
        var angle2 = helpers.angleBetweenTwoPoints(x, y, element.endPoint)

        if (helpers.isInsideAngle(angle1, element.startAngle, element.startAngle + Math.PI / 2) &&
          helpers.isInsideAngle(angle2, element.startAngle - Math.PI / 2, element.startAngle)) {
          return true
        }
      }
      return false
    })

    if (typeof shapeElement === 'undefined') {
      // probably line shape and out of bounds
      // make an extra effort and find the *closest* shapeElement

      shapeElement = shape.elements.reduce(function (bestElement, thisElement) {
        if (thisElement.type === 'line') {
          var distance = helpers.distanceFromPointToLineSegment(x, y, thisElement.startPoint, thisElement.endPoint)
          if(distance < bestElement.distance){
            return Object.assign({}, thisElement,
              {distance: distance})
          }
        }
        return bestElement
      }, {distance: 1440, initial: true})
    }

    // calculate the relative position inside the element
    // and find minutes
    var positionInShapeElement

    if (shapeElement.type === 'arc') {
      var angle = helpers.angleBetweenTwoPoints(x, y, shapeElement.startPoint)
      positionInShapeElement = helpers.getProgressBetweenTwoValues(angle, shapeElement.startAngle, shapeElement.endAngle)
    } else if (shapeElement.type === 'line') {
      var a = helpers.distanceFromPointToLineSegment(x, y, shapeElement.startPoint, shapeElement.endPoint)
      var b = helpers.distance(x, y, shapeElement.startPoint)
      var length = Math.sqrt(b * b - a * a)
      positionInShapeElement = length / shapeElement.length
      if (isNaN(positionInShapeElement)) {
        // this happens sometimes because 0/0 == NaN
        positionInShapeElement = 0
      }
    }
    var minutes = helpers.duration(shapeElement.start, shapeElement.end) * positionInShapeElement + shapeElement.start
    minutes = Math.min(minutes, 1440) // so you cant drag line elements to 1450 1460 ...

    // console.log(minutes)
    if (shapeElement.type === 'arc') {
      distance = helpers.distance(x, y, shapeElement.startPoint)
    } else if (shapeElement.type === 'line') {
      // TODO: this is a hotfix
      if(chart.data.shape == 'line'){
        distance = helpers.distanceFromPointToLine(y, shapeElement.startPoint.y)
      } else {
        distance = helpers.distanceFromPointToLineSegment(x, y, shapeElement.startPoint, shapeElement.endPoint)
      }
    }

    if (isNaN(minutes) || isNaN(distance)) {
      throw new 'ouch'()
    }

    var lanes = chart.shape.lanes
    var lane = lanes.findIndex(function (lane) { return (distance > lane.start && distance < lane.end); })
    return {
      minutes: minutes,
      distance: distance,
      lane: lane
    }
  }

  helpers.minutesToXY = function (chart, minutes, radius) {
    var ctx = chart.ctx
    var shape = chart.shape

    var minutes = helpers.limit(minutes)
    // Find out which shapeElement we find our point in
    var shapeElement = shape.elements.find(function (element) {
      return helpers.isInside(minutes, element.start, element.end)
    })

    if (typeof shapeElement === 'undefined') {
      console.warn(Object.assign({}, chart.shape), minutes, radius)
      throw new 'shapeElement==undefined'()
    }
    // Decimal used to calculate where the point is inside the shape
    var positionInShape = helpers.getProgressBetweenTwoValues(minutes, shapeElement.start, shapeElement.end)

    if (shapeElement.type === 'line') {
      var basePoint = {
        x: shapeElement.startPoint.x + Math.cos(shapeElement.startAngle) * positionInShape * shapeElement.length,
        y: shapeElement.startPoint.y + Math.sin(shapeElement.startAngle) * positionInShape * shapeElement.length
      }
      var point = {
        x: basePoint.x + Math.cos(shapeElement.startAngle - Math.PI / 2) * radius,
        y: basePoint.y + Math.sin(shapeElement.startAngle - Math.PI / 2) * radius
      }
    } else if (shapeElement.type === 'arc') {
      var centerOfArc = shapeElement.startPoint
      var angle = positionInShape * shapeElement.radians
      var point = {
        x: centerOfArc.x + Math.cos(shapeElement.startAngle + angle - Math.PI / 2) * radius,
        y: centerOfArc.y + Math.sin(shapeElement.startAngle + angle - Math.PI / 2) * radius
      }
    }

    return point
  }

  helpers.createCurve = function (chart, start, end, radius, anticlockwise, callback) {
    var ctx = chart.ctx
    if (typeof anticlockwise === 'undefined') {
      var anticlockwise = false
    }
    // the reason for this silly function inside function: callback see at the end
    function createCurve (start, end) {
      var shape = helpers.clone(chart.shape)
      if (anticlockwise) {
        shape.elements.reverse()
      }
      start = helpers.limit(start)
      end = helpers.limit(end)

      // find out which shapeElement has the start and end
      var startElementIndex, endElementIndex
      shape.elements.forEach(function (element, i) {
        if (helpers.isInside(start, element.start, element.end)) {
          startElementIndex = i
        }
        if (helpers.isInside(end, element.start, element.end)) {
          endElementIndex = i
        }
      })

      var shapeElements = []
      // create iterable task array
      var taskArray = []
      var skipEndCheck = false
      var defaultTask
      if (anticlockwise) {
        defaultTask = {
          start: 1,
          end: 0
        }
      } else {
        defaultTask = {
          start: 0,
          end: 1
        }
      }

      if (typeof startElementIndex === 'undefined' || typeof endElementIndex === 'undefined') {
        console.log(shape, start, end)
        throw 'error: something is not right here'
      }

      for (var i = startElementIndex; i < shape.elements.length; i++) {
        var task = {
          shapeElement: shape.elements[i],
          start: defaultTask.start,
          end: defaultTask.end
        }

        if (i == startElementIndex) {
          task.start = helpers.getPositionBetweenTwoValues(start, shape.elements[i].start, shape.elements[i].end)
        }
        if (i == endElementIndex) {
          task.end = helpers.getPositionBetweenTwoValues(end, shape.elements[i].start, shape.elements[i].end)
        }
        if (i == startElementIndex && i == endElementIndex && (task.end > task.start && anticlockwise) || (task.end < task.start && !anticlockwise)) {
          // make sure things are correct when end is less than start
          if (taskArray.length == 0) {
            // it is beginning
            task.end = defaultTask.end
            skipEndCheck = true
          } else {
            // it is end
            task.start = defaultTask.start
          }
        }

        taskArray.push(task)

        if (i == endElementIndex) {
          if (skipEndCheck) {
            skipEndCheck = false
            // let it run a round and add all shapes
          } else {
            // finished.. nothing more to do here!
            break
          }
        }

        // if we reached end of array without having found
        // the end point, it means that we have to go to
        // the beginning again
        // ex. when start:700 end:300
        if (i == shape.elements.length - 1) {
          i = -1
        }
      }
      taskArray.forEach(function (task, i) {
        var shapeElement = task.shapeElement
        if (shapeElement.type === 'arc') {
          var shapeStart = shapeElement.startAngle - (Math.PI / 2)
          var start = shapeStart + (task.start * shapeElement.radians)
          var end = shapeStart + (task.end * shapeElement.radians)
          ctx.arc(shapeElement.startPoint.x, shapeElement.startPoint.y, radius, start, end, anticlockwise)
        } else if (shapeElement.type === 'line') {
          var startPoint = helpers.minutesToXY(chart, shapeElement.start + shapeElement.minutes * task.start, radius)
          var endPoint = helpers.minutesToXY(chart, shapeElement.start + shapeElement.minutes * task.end, radius)
          ctx.lineTo(startPoint.x, startPoint.y)
          ctx.lineTo(endPoint.x, endPoint.y)
        }
      })
    }
    if (typeof callback === 'undefined') {
      createCurve(start, end)
    } else {
      // callback makes it possible for this function to do two operations
      // instead of one, thus be able to draw when shape is a straight line
      if (!chart.shapeIsContinous && start > end) {
        createCurve(start, 1440)
        callback()

        chart.ctx.beginPath() // this is a hotfix
        createCurve(0, end)
        callback()
      } else {
        createCurve(start, end)
        callback()
      }
    }
  }

  helpers.createSegment = function (chart, outer, inner, start, end, callback) {
    function createSegment (start, end) {
      var ctx = chart.ctx
      ctx.beginPath()
      helpers.createCurve(chart, start, end, outer)
      helpers.createCurve(chart, end, start, inner, true)
      ctx.closePath()
    }

    if (typeof callback === 'undefined') {
      createSegment(start, end)
    } else {
      // callback makes it possible for this function to do two operations
      // instead of one, thus be able to draw when shape is a straight line
      if (!chart.shapeIsContinous && start > end) {
        createSegment(start, 1440)
        callback()

        createSegment(0, end)
        callback()
      } else {
        createSegment(start, end)
        callback()
      }
    }
  }
}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

/*
 *  config
 *
 *  All entries that are numbers will be scaled in core.js
 *
 */

module.exports = function (Napchart) {
  Napchart.config = {
    interaction: true,
    penMode: true,
    baseRadius: 32,
    edgeRadius: 42,
    background: 'transparent',
    font: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
    ampm: false,
    fontSize: {
      small: 1.75,
      medium: 2.25,
      big: 3.5
    },
    baseFontSize: 'noscale:1', // all other font sizes multiply this
    fontColor: '#aaaaaa',
    cornerRadius: 3,
    text: true,
    drawFace: true,
    paddingLanes: 0.4,
    face: { // define how the background clock should be drawn
      stroke: 0.15,
      weakStrokeColor: '#dddddd',
      weakerStrokeColor: '#f5f5f5',
      strokeColor: '#aaaaaa',
      importantStrokeColor: 'black',
      importantLineWidth: 0.3,
      numbers: {
        distance: 6,
        color: '#262626'
      }
    },
    content: {
      handleTimes: {
        distance: 2.5,
        color: '#999999'
      },
      handles: 0.6,
      bigHandles: 1.4,
      textDistance: 3,
      textBoxPadWidth: 0.9
    },
    handlesClickDistance: 3,
    defaultColor: 'red',
    colorMap: {
      red: '#D02516',
      blue: '#4285F4',
      brown: '#B15911',
      green: '#34A853',
      gray: '#949494',
      yellow: '#FBBC05',
      purple: '#730B73',
      pink: '#ff94d4',
      white: '#ffffff'
    },
    colorTagsSize: 2.0
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports) {

/*
 *  Core module of Napchart
 *
 */

module.exports = function (Napchart) {
  var helpers = Napchart.helpers

  Napchart.init = function (ctx, data, config) {
    // methods of instance:

    var chart = {
      setHover: function (id, type) {
        this.hoverElement = {
          id: id,
          type: type
        }

        draw(this)
      },

      isHover: function (id, type) {
        return (this.hoverElement.id == id) && (this.hoverElement.type == type)
      },

      isActive: function (id, type) {
        return (this.activeElement.elementId == id) && (this.activeElement.type == type)
      },

      setActive: function (hit) {
        this.activeElement = hit
      },

      removeActive: function () {
        this.activeElement = {}

        draw(this)
      },

      removeHover: function () {
        this.hoverElement = {}

        draw(this)
      },

      setSelected: function (id) {
        this.selectedElement = id
        this.onUpdate()

        this.onSetSelected(id)

        draw(this)
      },

      isSelected: function (id) {
        return this.selectedElement == id
      },

      deselect: function () {
        this.selectedElement = false
        this.onUpdate()

        this.onSetSelected(false)

        draw(this)
      },

      isPen: function () {
        // checks:
        // penMode, no element under cursor(hover), not dragging (active),
        // and that the pen location is made (it is in lane etc)
        return (
          chart.config.penMode &&
          Object.keys(this.hoverElement).length == 0 &&
          Object.keys(this.activeElement).length == 0 &&
          this.mousePenLocation)
      },

      setShape: function (shape) {},

      animateShape: function (shape) {},

      initAndAddElements: function (newElements) {
        newElements = verifyAndInitElements(newElements, chart)

        this.data.elements = this.data.elements.concat( newElements
        )

        this.draw()
      },

      setElements: function (elements) {
        var helpers = this.helpers
        elements = elements.map(function (element) {
          return Object.assign({}, element,
            {start: helpers.limit(element.start),
            end: helpers.limit(element.end)})
        })
        this.data.elements = elements

        this.draw()
      },

      updateElement: function (changes) {
        // needs id and properties to change
        this.data.elements = this.data.elements.map(function (element) {
          if (element.id == changes.id) {
            return Object.assign(element, changes)
          }
          return element
        })

        draw(this)
      },

      updateManyElements: function (relativeChanges, ids) {
        // needs id and properties to change
        this.data.elements = this.data.elements.map(function (element) {
          if (ids.indexOf(element.id) > -1) {
            return Object.assign({}, element,
              {start: helpers.limit(element.start + relativeChanges.start),
              end: helpers.limit(element.end + relativeChanges.end)})
          }
          return element
        })

        draw(this)
      },

      deleteElement: function (id) {
        this.data.elements = this.data.elements.filter(function (e) { return e.id != id; })

        if (this.isSelected(id)) {
          this.deselect()
        }

        this.history.add('Delete element')

        draw(this)
      },

      emptyLane: function (laneIndex) {
        this.data.elements = this.data.elements.filter(function (e) { return e.lane != laneIndex; })
      },

      deleteLane: function (laneIndex) {
        var this$1 = this;

        if (this.data.lanes == 1) {
          console.error('Cant delete last lane')
          return
        }
        this.emptyLane(laneIndex)

        // we need to change all elements in lanes > laneIndex to get the correct lane
        this.data.elements = this.data.elements.map(function (el) {
          if (el.lane < laneIndex) {
            return el
          }
          return Object.assign({}, el,
            {lane: el.lane - 1})
        })

        // delete laneConfig
        delete this.data.lanesConfig[laneIndex]

        //change laneConfigs to point to the correct lane
        Object.keys(this.data.lanesConfig).forEach(function (key) {
          if (key < laneIndex) {
            return
          }
          if (key == laneIndex) {
            return console.error("WHAT?? this key should have been deleted")
          }
          if (key > laneIndex) {
            // shift one down
            this$1.data.lanesConfig[laneIndex - 1] = Object.assign({}, this$1.data.lanesConfig[laneIndex])
            delete this$1.data.lanesConfig[laneIndex]
          }
        })

        this.data.lanes -= 1

        chart.history.add('Delete lane')
        chart.needFullRedraw = true
        Napchart.shape.initShape(chart)
        draw(this)
      },

      addLane: function (laneIndex) {
        this.data.lanes += 1

        chart.history.add('Add lane')
        chart.needFullRedraw = true
        Napchart.shape.initShape(chart)
        draw(this)
      },

      toggleLockLane: function (laneIndex) {
        var current = this.getLaneConfig(laneIndex)
        this.data.lanesConfig[laneIndex] = {
          // ...this.data.lanesConfig[laneIndex], future when adding more laneconfig options
          locked: !current.locked
        }
        
        console.log(this.data.lanesConfig[laneIndex])
        chart.needFullRedraw = true

        draw(this)
      },

      getLaneConfig: function (laneIndex) {
        var defaultLaneConfig = {
          locked: false
        }

        return Object.assign({}, defaultLaneConfig,
          this.data.lanesConfig[laneIndex])
      },

      createElement: function (newElement) {
        var element = verifyAndInitElements([newElement], this)[0]
        chart.data.elements.push(element)

        draw(this)

        return element
      },

      changeColor: function (id, color) {
        this.data.elements = this.data.elements.map(function (e) {
          if (e.id == id) {
            return Object.assign({}, e,
              {color: color})
          } else {
            return e
          }
        })

        chart.history.add('Change color')

        draw(this)
      },

      colorTag: function (color, tag) {
        // 1 delete if tag empty
        if (tag == '') {
          return this.data.colorTags = this.data.colorTags.filter(function (t) { return t.color != color; })
        }


        // 2 create if not exist
        var tagObj = this.data.colorTags.find(function (t) { return t.color == color; })
        if (typeof tagObj == 'undefined') {
          this.data.colorTags.push({
            color: color
          })
        }

        // 3 change tag value
        this.data.colorTags = this.data.colorTags.map(function (t) {
          if (t.color == color) {
            return Object.assign({}, t,
              {tag: tag})
          }
          return t
        })
        draw(this)
      },

      draw: function () {
        draw(chart)
      },

      benchmark: function () {
        Napchart.draw.benchmark(this)
      },

      // setConfig: function(config) {
      //   // Napchart.config = config
      //   chart.config = config
      //   scaleConfig(chart.config, chart.ratio)
      //   this.redraw()
      // },

      onSetSelected: function () {},

      onUpdate: function () {},

      // this function should only be used by a listener
      // to update napchart
      update: function (data) {
        chart.data = data

        draw(chart)
        console.log('updating')
      },

      updateDimensions: function () {
        // probably because of resize

        scale(chart)

        chart.needFullRedraw = true
        Napchart.shape.initShape(chart)

        draw(this)
      },

      changeShape: function (to) {
        Napchart.shape.changeShape(chart, to)
        this.data.shape = to
      },
    }

    // properties of instance:
    var defaultData = {
      elements: [],
      colorTags: [],
      shape: 'circle',
      lanes: 1,
      lanesConfig: {
        1: {
          locked: false
        }
      }
    }

    chart.ctx = ctx
    chart.canvas = ctx.canvas
    chart.unScaledConfig = initConfig(config)
    
    scale(chart)

    chart.data = helpers.extend(defaultData, data)
    chart.hoverElement = {}
    chart.activeElement = {}
    chart.selectedElement = false
    chart.mousePenLocation = false
    chart.needFullRedraw = true
    chart.isTouchUser = false

    // initialize:
    chart.helpers = Napchart.helpers
    chart.styles = Napchart.styles

    Napchart.shape.initShape(chart)
    Napchart.interactCanvas.init(chart)
    Napchart.history.init(chart)

    chart.history.add('Initial')

    // add properties like id, lane, color etc if not there
    chart.data.elements = verifyAndInitElements(chart.data.elements, chart)

    draw(chart)
    return chart
  }

  // private
  function scale(chart) {
    var canvas = chart.canvas
    retinaScale(chart)
    chart.width = chart.w = canvas.width
    chart.height = chart.h = canvas.height
    chart.ratio = Math.min(chart.w / 90, chart.h / 90)
    chart.config = scaleConfig(chart.unScaledConfig, chart.ratio)
  }

  function draw(chart) {
    // here we need to determine how much we should redraw
    if (chart.needFullRedraw) {
      Napchart.draw.fullDraw(chart)
      chart.needFullRedraw = false
      chart.onUpdate() // notify listeners
    } else {
      Napchart.draw.drawFrame(chart)
    }
  }

  function retinaScale(chart) {
    if (typeof window === 'undefined') {
      // we are in node.js
      return
    }
    var canvas = chart.canvas
    var dpr = window.devicePixelRatio

    var _parent = canvas.parentNode
    var WIDTH = _parent.offsetWidth
    var HEIGHT = _parent.offsetHeight

    canvas.width = dpr * WIDTH
    canvas.height = dpr * HEIGHT

    canvas.style.width = '100%'
    canvas.style.height = '100%'
  }

  function initConfig(config) {
    config = config || {}
    config = helpers.extend(JSON.parse(JSON.stringify(Napchart.config)), config)
    return config
  }

  function verifyAndInitElements(elements, chart) {
    return elements.map(function (element) {
      if (typeof element.start === 'undefined' ||
        typeof element.end === 'undefined') {
        throw new Err('Start and End properties are required!')
      }
      var element = {
        start: element.start,
        end: element.end,
        id: element.id || idGen(),
        lane: element.lane || 0,
        text: element.text || '',
        color: element.color || chart.config.defaultColor
      }
      if (element.lane > (chart.shape.lanes.length - 1)) {
        console.log(("Lane no. " + (element.lane) + " does not exist in this chart.\n        Number of lanes: " + (chart.shape.lanes.length)))
      }

      return element
    })

    function idGen() {
      var id = Math.round(Math.random() * 10000)
      return id
    }
  }



  function scaleConfig(config, ratio) {
    var scaledConfig = helpers.clone(config)

    function scaleFn(base, value, key) {
      if (value > 1 || value < 1 || value === 1) { // if value is a number
        base[key] = value * ratio
      }
    }
    helpers.deepEach(scaledConfig, scaleFn)
    return scaledConfig
  }
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/*
*
* Shape module
*
*/

var shapes = initShapes(__webpack_require__(9))
var calculateShape = __webpack_require__(1)
var animateShape = __webpack_require__(10)

module.exports = function (Napchart) {
  var helpers = Napchart.helpers
  var currentShape

  Napchart.shape = {
    initShape: function (chart) {
      setShape(chart, chart.data.shape)
    },
    changeShape: function (chart, to) {
      changeShape(chart, to)
    }
  }

  function setShape (chart, shape) {
    if (typeof shape === 'string') {
      currentShape = shape
      shape = shapes[shape]
    }
    chart.shape = calculateShape(chart, shape)
  }

  function changeShape (chart, wantToShape) {
    // we are this shape:
    var currentShape = chart.data.shape

    // make a sequence of shapes for smoother animations
    var shapeSequenze = [wantToShape] // default to direct
    if (currentShape == 'circle') {
      if (wantToShape == 'line') {
        shapeSequenze = ['transitionShape', 'line']
      }
    } else if (currentShape == 'wide') {
      if (wantToShape == 'line') {
        shapeSequenze = ['circle', 'transitionShape', 'line']
      }
    } else if (currentShape == 'line') {
      if (wantToShape == 'wide') {
        shapeSequenze = ['transitionShape', 'circle', 'wide']
      } else if (wantToShape == 'circle') {
        shapeSequenze = ['transitionShape', 'circle']
      }
    }

    var index = 0
    function next () {
      var oldShape = helpers.clone(shapes[currentShape])
      var newShape = helpers.clone(shapes[shapeSequenze[index]])
      var globalProgress = {
        count: shapeSequenze.length
      }
      animateShape(chart, oldShape, newShape, globalProgress, function () {
        currentShape = shapeSequenze[index]
        index++
        if (index < shapeSequenze.length) {
          next()
        }
      })
    }

    next()
  }
}

function initShapes(shapes) {
  for(var shapeString in shapes){
    var shape = shapes[shapeString]
    shapes[shapeString] = Object.assign({}, shape,
      {laneMaxRadius: shape.laneMaxRadius || 36,
      laneMinRadius: shape.laneMinRadius || 16,
      maxLaneSize: shape.maxLaneSize || 14,
      shiftDown: shape.shiftDown || 0,
      shift: shape.shift || 0,
      centerMinutes: shape.centerMinutes || 0})
  }
  return shapes
}

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = {
  miniCircle: {
    elements: [{
        type: 'arc',
        radians: Math.PI
      },
      {
        type: 'line',
        percent: 0 // percent
      },
      {
        type: 'arc',
        radians: Math.PI
      },
      {
        type: 'line',
        percent: 0 // percent
      }
    ],
    laneMinRadius: 16
  },
  circle: {
    elements: [{
        type: 'arc',
        radians: Math.PI
      },
      {
        type: 'line',
        percent: 0 // percent
      },
      {
        type: 'arc',
        radians: Math.PI
      },
      {
        type: 'line',
        percent: 0 // percent
      }
    ]
  },
  line: {
    elements: [{
      type: 'line',
      percent: 100
    }],
    laneMaxRadius: 60,
    laneMinRadius: 0,
    maxLaneSize: 20,
    shiftDown: 30,
    centerMinutes: 720,
  },
  wide: {
    elements: [{
        type: 'arc',
        radians: Math.PI
      },
      {
        type: 'line',
        percent: 100 // percent
      },
      {
        type: 'arc',
        radians: Math.PI
      },
      {
        type: 'line',
        percent: 100 // percent
      }
    ],
    shift: 0,
    centerMinutes: 1350,
  },
  transitionShape: {
    elements: [{
      type: 'arc',
      radians: Math.PI / 6
    }]
  }
  // smile: {
  //   elements: [
  //     {
  //       type: 'arc',
  //       radians: Math.PI/4
  //     },
  //   ],
  //   shift: 0
  // },
  // verticalEllipse: [
  //   {
  //     type: 'arc',
  //     value: Math.PI/2
  //   },
  //   {
  //     type: 'line',
  //     value: 150
  //   },
  //   {
  //     type: 'arc',
  //     value: Math.PI
  //   },
  //   {
  //     type: 'line',
  //     value: 150
  //   },
  //   {
  //     type: 'arc',
  //     value: Math.PI/2
  //   }
  // ],
  // fucked: [
  //   {
  //     type: 'arc',
  //     value: Math.PI/2*3
  //   },
  //   {
  //     type: 'line',
  //     value: 100
  //   },
  //   {
  //     type: 'arc',
  //     value: Math.PI/2
  //   },
  //   {
  //     type: 'line',
  //     value: 100
  //   },
  //   {
  //     type: 'arc',
  //     value: Math.PI/2
  //   },
  //   {
  //     type: 'line',
  //     value: 50
  //   },
  // ]
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var calculateShape = __webpack_require__(1)

module.exports = function animateShape (chart, shape, newShape, globalProgress, callback) {
  var helpers = chart.helpers

  // here is how it works:
  // takes newShape and makes it look like the old shape
  // then animate the values of shape to be like newShape

  newShape.elements.forEach(function (element) {
    if (element.type == 'line') {
      var property = 'percent'
    } else {
      var property = 'radians'
    }

    // find an element that is similar and remove it from old shape
    var elementFromOldShape = shape.elements.find(function (e, i) {
      if (element.type === e.type) {
        return shape.elements.splice(i, 1)
      }
    })
    if (typeof elementFromOldShape === 'undefined') {
      // we have to make one
      elementFromOldShape = {
        type: element.type
      };
      elementFromOldShape[property] = 0
    }

    element.animation = {
      start: elementFromOldShape[property],
      end: element[property],
      property: property
    }
  })

  // if there still are elements in the old shape,
  // that means that we have to add them in now (they will be killed)
  shape.elements.forEach(function (element) {
    if (element.type == 'line') {
      var property = 'percent'
    } else {
      var property = 'radians'
    }

    newShape.elements.push({
      type: element.type,
      animation: {
        start: element[property],
        end: 0,
        property: property
      }
    })
  })

  // other animations
  var propsToAnimate = ['shift', 'shiftDown', 'laneMinRadius', 'laneMaxRadius', 'maxLaneSize', 'centerMinutes']
  newShape.propAnimations = propsToAnimate.map(function (prop) {
    return {
      prop: prop,
      start: shape[prop],
      end: newShape[prop],
      duration: newShape[prop] - shape[prop]
    }
  })

  var timeShouldUse = 350
  var startTime = Date.now()
  var endTime = startTime + timeShouldUse

  function every () {
    var nowTime = Date.now()
    var progress = Math.min(1, (nowTime - startTime) / timeShouldUse)

    progress = applyEasing(progress)

    newShape.elements.forEach(function (element, i) {
      var duration = element.animation.end - element.animation.start
      element[element.animation.property] = element.animation.start + duration * progress
    })

    // prop animations
    newShape.propAnimations.forEach(function (anim) {
      newShape[anim.prop] = anim.start + anim.duration * progress
    })

    chart.shape = calculateShape(chart, newShape)
    chart.needFullRedraw = true
    chart.draw()

    if (progress < 1) {
      window.requestAnimationFrame(every)
    } else {
      callback()
    }
  }

  every()

  function applyEasing (progress) {
    // return progress
    return helpers.easingEffects.easeInOutQuad(progress)
  }
}


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = function (Napchart) {
  // textHelper
  var textHelper = __webpack_require__(0)

  Napchart.draw = {
    fullDraw: fullDraw,
    drawFrame: draw,
    benchmark: benchmark
  }

  var clear = __webpack_require__(12)

  var tasks = [

    // - face

    function (chart) {
      if (typeof chart.ocanvas !== 'undefined') {
        chart.ctx.drawImage(chart.ocanvas, 0, 0)
      }
    },

    // - content

    // -- bars
    __webpack_require__(13),
    // -- handles
    __webpack_require__(14),
    // -- handleTimes
    __webpack_require__(15),
    // -- text
    __webpack_require__(16),
    // -- durations
    __webpack_require__(17),
    // -- distances
    __webpack_require__(18),
    // -- pen
    __webpack_require__(19),
    // -- text strings
    textHelper.writeAll,
    // -- colorTags
    __webpack_require__(20) ]

  var faceTasks = [
    // -- circles
    __webpack_require__(21),
    // -- circles
    __webpack_require__(22),
    // -- lines
    __webpack_require__(23),
    // -- numbers
    __webpack_require__(24)
  ]

  function fullDraw (chart) {
    var ctx = chart.ctx

    ctx.font = chart.config.fontSize + 'px ' + chart.config.font
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'

    clear(chart)

    if (typeof document === 'undefined') {
      // we are in a node environment
      // dont do the offscreen thing
      faceTasks.forEach(function (task) {
        task(chart, chart.ctx)
      })
      tasks.forEach(function (task) {
        task(chart, chart.ctx)
      })
    } else {
      chart.ocanvas = document.createElement('canvas')
      chart.ocanvas.width = chart.width
      chart.ocanvas.height = chart.height
      var octx = chart.ocanvas.getContext('2d')

      // here I create a sligthly modified chart object faceChart
      // please don't get confused by this, you should really
      // just think that there is one chart object to rule
      // them all (each instance)
      var faceChart = Object.assign({}, chart, {ctx: octx})
      faceTasks.forEach(function (task) {
        task(faceChart, octx)
      })

      draw(chart)
    }
  }

  // mini function that draws only the things
  // that usually change
  // (does not update clock-face, settings, shape etc)
  function draw (chart) {
    clear(chart)

    tasks.forEach(function (task) {
      task(chart, Napchart)
    })
  }

  function benchmark (chart) {
    var iterations = 1000
    var bigstart = Date.now()
    for (task in tasks) {
      var start = Date.now()
      for (var i = 0; i < iterations; i++) {
        tasks[task](chart, Napchart)
      }
      var end = Date.now()
      console.log(task + " x " + iterations + " " + (end - start) + ' ms')
    }
    var bigend = Date.now()
    console.log("Total: " + (bigend - bigstart) + ' ms')
    console.log("One round: " + ((bigend - bigstart) / iterations) + ' ms')
  }
}


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = function (chart) {
  var ctx = chart.ctx
  ctx.clearRect(0, 0, chart.w, chart.h)
}


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config

  // fill
  chart.data.elements.forEach(function (element) {
    var lane = chart.shape.lanes[element.lane]
    ctx.save()
    ctx.fillStyle = helpers.colorMap(chart, element.color)
    if (chart.isActive(element.id, 'middle')) {
      ctx.globalAlpha = 0.9
    }

    helpers.createSegment(chart, lane.end - config.paddingLanes, lane.start + config.paddingLanes, element.start, element.end, function () {
      ctx.fill()
    })

    ctx.restore()
  })
}

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config
  var data = chart.data

  var element = data.elements.find(function (e) { return e.id == chart.selectedElement; })
  if (typeof element === 'undefined') {
    return
  }
  var lane = chart.shape.lanes[element.lane]

  ctx.save()

  var arr = ['start', 'end']

  arr.forEach(function (startOrEnd) {
    var handlePosition = helpers.minutesToXY(chart, element[startOrEnd], lane.end - config.paddingLanes)

    ctx.globalAlpha = 0.5
    ctx.fillStyle = helpers.colorMap(chart, element.color)

    helpers.circle(chart, handlePosition, config.content.handles)
    ctx.fill()

    if (chart.isHover(element.id, startOrEnd) || chart.isActive(element.id, startOrEnd)) {
      ctx.globalAlpha = 0.2
      ctx.fillStyle = helpers.colorMap(chart, element.color)

      helpers.circle(chart, handlePosition, config.handlesClickDistance)
      ctx.fill()
    }
  })
  ctx.restore()
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var textHelper = __webpack_require__(0)

module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config

  if (!config.text) { return }

  chart.data.elements.forEach(function (element) {
    var lane = chart.shape.lanes[element.lane]

    ctx.save()

    var arr = ['start', 'end']

    arr.forEach(function (startOrEnd) {
      var settings = config.content.handleTimes

      var radius = lane.end + settings.distance
      if (element.lane == 0) {
        var radius = lane.start - settings.distance
      }

      ctx.fillStyle = settings.color

      var position = helpers.minutesToXY(chart, element[startOrEnd], radius)
      textHelper.string(helpers.minutesToClock(chart, element[startOrEnd]), position.x, position.y, {
        size: config.fontSize.small,
        color: config.content.handleTimes.color
      })
    })

    ctx.restore()
  })
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var textHelper = __webpack_require__(0)

module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config

  if (!config.text) { return }

  chart.data.elements.forEach(function (element) {
    var text = element.text
    if (text.length == 0) {
      return
    }

    var lane = chart.shape.lanes[element.lane]

    ctx.save()
    var middleMinutes = helpers.middlePoint(element.start, element.end)
    if (helpers.duration(element.start, element.end) < 90) {
      middleMinutes = Math.max(middleMinutes, element.start + 40)
    }

    var radius = lane.end + chart.config.content.textDistance
    if (element.lane == 0) {
      var radius = lane.start - chart.config.content.textDistance
    }

    var textPosition = helpers.minutesToXY(chart, middleMinutes, radius)

    textHelper.string(element.text, textPosition.x, textPosition.y, {
      size: chart.config.fontSize.small,
      color: 'white',
      background: helpers.colorMap(chart, element.color)
    })

    ctx.restore()
  })
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var textHelper = __webpack_require__(0)

module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config

  if (!config.text) { return }

  chart.data.elements.forEach(function (element) {
    var lane = chart.shape.lanes[element.lane]

    ctx.save()
    var middleMinutes = helpers.middlePoint(element.start, element.end)

    var radius = (lane.start + lane.end) / 2
    var textPosition = helpers.minutesToXY(chart, middleMinutes, radius)
    var duration = helpers.minutesToReadable(helpers.duration(element.start, element.end))

    textHelper.string(duration, textPosition.x, textPosition.y, {
      size: config.fontSize.medium,
      color: 'white',
      background: helpers.colorMap(chart, element.color),
      roundedCorners: true
    })

    ctx.restore()
  })
}


/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config

  // we need to go through one lane at the time and check if we
  // should draw distances

  chart.shape.lanes.forEach(function (lane, i) {
    var elementsWithThisLane = chart.data.elements.filter(function (e) { return e.lane == i; })
    if (chart.getLaneConfig(i).locked && elementsWithThisLane.length > 0) {
      drawDistanceToElements(elementsWithThisLane, true)
    } else {
      elementsWithThisLane.forEach(function (element) {
        if (chart.isSelected(element.id)) {
          drawDistanceToElements(elementsWithThisLane, false)
        }
      })
    }
  })

  function drawDistanceToElements(elements, locked) {
    var lane = chart.shape.lanes[elements[0].lane]

    ctx.save()

    // sort array
    elements = elements.sort(function (a, b) {
      return a.start - b.start
    })

    // SECOND - draw
    ctx.fillStyle = config.face.strokeColor
    ctx.strokeStyle = config.face.weakStrokeColor
    if (locked) {
      ctx.strokeStyle = config.face.strokeColor
      ctx.lineWidth = config.face.importantLineWidth
    }
    // push start and endpoints to draw elements
    var drawArr = []
    elements.forEach(function (el, i) {
      if (i == elements.length - 1) {
        var next = elements[0]
      } else {
        var next = elements[i + 1]
      }

      drawArr.push({
        start: el.end,
        end: next.start
      })
    })

    var radius = lane.start + (lane.end - lane.start) / 3
    var textRadius = lane.start + (lane.end - lane.start) * 2 / 3

    drawArr.forEach(function (element) {
      var distance = helpers.duration(element.start, element.end)
      var text = helpers.minutesToReadable(distance, 120)

      if (distance >= 60) {
        var start = helpers.limit(element.start + 15)
        var end = helpers.limit(element.end - 15)
        var middle = helpers.limit(start + (distance / 2))

        ctx.beginPath()
        // stroke
        helpers.createCurve(chart, start, end, radius, false, function () {
          ctx.stroke()
        })

        ctx.font = helpers.fontSize(chart, config.fontSize.small)

        // TODO
        // subracting 10 because of text width
        // should probably find a way to calculate it better
        var middleXY = helpers.minutesToXY(chart, middle - 10, textRadius)
        // text
        ctx.fillText(text, middleXY.x, middleXY.y)
      }
    })

    ctx.restore()
  }
}

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config
  if (chart.isPen()) {
  	var minutes = chart.mousePenLocation.minutes
  	var lane = chart.shape.lanes[chart.mousePenLocation.lane]

  	ctx.save()
  	ctx.fillStyle = chart.config.defaultColor
  	ctx.globalAlpha = 0.5
    var start = helpers.limit(minutes - 1)
    var end = helpers.limit(minutes + 1)
  	helpers.createSegment(chart, lane.end - config.paddingLanes, lane.start + config.paddingLanes, start, end, function () {
  	  ctx.fill()
  	})

  	ctx.restore()
  }
}


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var textHelper = __webpack_require__(0)
module.exports = function (chart) {
  var ctx = chart.ctx
  var helpers = chart.helpers
  var config = chart.config
  
  ctx.save()

  ctx.fillStyle="black"
  var textPosition = helpers.minutesToXY(chart, chart.shape.centerMinutes, chart.shape.lanes[0].start - chart.shape.laneMinRadius/2 * chart.ratio)

  var colorTags = chart.data.colorTags
  colorTags.forEach(function(tagObj) {
  	textPosition.y += config.colorTagsSize * 1.5
  	var minutes = chart.data.elements.reduce(function (minutes, element) {
  	  if(element.color == tagObj.color){
  	    return minutes + helpers.duration(element.start, element.end)
  	  }else{
  	    return minutes
  	  }
  	}, 0)
  	var text = tagObj.tag + ': ' + helpers.minutesToReadable(minutes)
    ctx.font = helpers.fontSize(chart, config.fontSize.medium)

    ctx.fillText(text, textPosition.x, textPosition.y)

    var squareSize = config.fontSize.medium

  	var width = ctx.measureText(text).width
  	var squarePosition = {
  		x: textPosition.x - width/2 - squareSize - config.fontSize.medium/2,
  		y: textPosition.y - config.fontSize.medium/2
  	}
  	ctx.save()

  	ctx.fillStyle = helpers.colorMap(chart, tagObj.color)
  	ctx.fillRect(squarePosition.x, squarePosition.y, squareSize, squareSize)
  	ctx.restore()
  })

  ctx.restore()
}

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = function (chart, ctx) {
  if (chart.config.background != 'transparent') {
    ctx.save()
    ctx.fillStyle = chart.config.background

    ctx.fillRect(0, 0, chart.w, chart.h)

    ctx.restore()
  }
}


/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = function (chart, ctx) {
  var lanes = chart.shape.lanes
  var helpers = chart.helpers

  if(!chart.config.drawFace){
    return
  }

  ctx.lineWidth = chart.config.face.stroke
  ctx.strokeStyle = chart.config.face.strokeColor

  ctx.save()
  ctx.strokeStyle = chart.config.face.weakerStrokeColor
  for (var i = 0; i < lanes.length - 1; i++) {
    // ctx.setLineDash([1, 1])

    ctx.beginPath()
    helpers.createCurve(chart, 0.01, 1439.9, lanes[i].end)
    ctx.stroke()

    ctx.setLineDash([])
  }
  ctx.restore()

  ctx.beginPath()
  helpers.createCurve(chart, 0.01, 1439.9, lanes[0].start)
  ctx.stroke()

  ctx.beginPath()
  helpers.createCurve(chart, 0.01, 1439.9, lanes[lanes.length - 1].end)
  ctx.stroke()
}


/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = function (chart, ctx) {
  var helpers = chart.helpers
  var config = chart.config
  var lanes = chart.shape.lanes

  if(!config.drawFace){
    return
  }

  ctx.lineWidth = config.face.stroke
  ctx.save()

  // every hour normal

  // ctx.strokeStyle = config.face.strokeColor
  // ctx.beginPath()

  // for (var i = 0; i < 24; i++) {
  // 	var s = helpers.minutesToXY(chart, i * 60, lanes[lanes.length - 1].end)
  // 	var e = helpers.minutesToXY(chart, i * 60, lanes[lanes.length - 1].end + 15 + config.face.hourStrokesLength)
  //   ctx.moveTo(s.x, s.y)
  //   ctx.lineTo(e.x, e.y)
  // }
  // ctx.stroke()

  // every hour weak

  ctx.strokeStyle = config.face.weakStrokeColor
  ctx.setLineDash([2, 4])

  ctx.beginPath()

  for (var i = 0; i <= 24; i++) {
    if (i == 24 && chart.shapeIsContinous) {
      continue
    }
    var s = helpers.minutesToXY(chart, i * 60, lanes[0].start)
    var e = helpers.minutesToXY(chart, i * 60, lanes[lanes.length - 1].end)
    ctx.moveTo(s.x, s.y)
    ctx.lineTo(e.x, e.y)
  }
  ctx.stroke()
  ctx.setLineDash([])

  // important hours

  // ctx.lineWidth = config.face.importantLineWidth
  // ctx.strokeStyle = config.face.importantStrokeColor
  // ctx.beginPath()

  // for(var i=0;i<=24;i = i+4){
  //   if(i == 24 && chart.shapeIsContinous){
  //     continue
  //   }
  //   var s = helpers.minutesToXY(chart, i*60, 25)
  //   var e = helpers.minutesToXY(chart, i*60, lanes[lanes.length - 1].end + config.face.hourStrokesLength)
  //   ctx.moveTo(s.x,s.y)
  //   ctx.lineTo(e.x,e.y)
  // }

  // ctx.stroke()

  // every 10 minutes

  /*
  ctx.strokeStyle = config.face.strokeColor
  ctx.beginPath()

  for(var i=0;i<1440/10;i++){
    var s = helpers.minutesToXY(chart, i*10, lanes[lanes.length - 2].end)
    var e = helpers.minutesToXY(chart, i*10, lanes[lanes.length - 2].end + config.face.tenMinuteStrokesLength)
    ctx.moveTo(s.x,s.y)
    ctx.lineTo(e.x,e.y)
  }
  ctx.stroke()
  ctx.beginPath()
  */

  // every 5 minutes

  /*
  ctx.strokeStyle = config.face.strokeColor
  ctx.beginPath()

  for(var i=0.5;i<1440/10;i++){
    var s = helpers.minutesToXY(chart, i*10, lanes[lanes.length - 2].end)
    var e = helpers.minutesToXY(chart, i*10, lanes[lanes.length - 2].end + config.face.fiveMinuteStrokesLength)
    ctx.moveTo(s.x,s.y)
    ctx.lineTo(e.x,e.y)
  }

  ctx.stroke()
  */

  ctx.restore()
}


/***/ }),
/* 24 */
/***/ (function(module, exports) {

// var textHelper = require('../textHelper')

module.exports = function (chart, ctx) {
  var helpers = chart.helpers
  var config = chart.config

  if(!config.drawFace){
    return
  }

  ctx.save()
  ctx.font = helpers.fontSize(chart, config.fontSize.big)
  ctx.fillStyle = config.face.numbers.color
  ctx.textAlign = 'center'
  ctx.textBaseline = 'middle'

  var endLane = chart.shape.lanes[chart.shape.lanes.length - 1]

  for (var i = 0; i <= 24; i = i + 1) {
    if (i == 24 && chart.shapeIsContinous) {
      return
    }
  	var p = helpers.minutesToXY(chart, i * 60, endLane.end + config.face.numbers.distance)

    var text = i

    if(config.ampm){
      if(text == 0){
        text = 'midnight'
      } else if (text < 12) {
        text = text + ' am'
      } else if(text == 12){
        text = 'noon'
      } else if(text > 12){
        text = text - 12 + ' pm'
      }
    }

    ctx.fillText(text, p.x, p.y)

  }

  ctx.restore()
}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *  interactCanvas
 *
 *  This module adds support for modifying a schedule
 *  directly on the canvas with mouse or touch
 */

var hitDetect = __webpack_require__(26)
var keyboard = __webpack_require__(27)

module.exports = function (Napchart) {
  var helpers = Napchart.helpers

  Napchart.interactCanvas = {
    init: function (chart) {
      if (!chart.config.interaction) {
        return
      }

      // helper function for event listeners
      function addListeners(element, eventNames, listener) {
        eventNames.split(' ').forEach(function (eventName) {
          element.addEventListener(eventName, listener)
        })
      }

      // first a little function for detecting touch users and setting
      // global prop
      window.addEventListener('touchstart', function onFirstTouch() {
        // set global variable
        chart.isTouchUser = true

        // we only need to know once that a human touched the screen, so we can stop listening now
        window.removeEventListener('touchstart', onFirstTouch, true);
      }, true);

      // move
      addListeners(document, 'mousemove touchmove', function (e) {
        if (chart.data.activeElement) {
          e.stopPropagation()
          e.preventDefault()
        }
        move(e, chart)
      })

      // down
      addListeners(chart.canvas, 'mousedown touchstart', function (e) {
        down(e, chart)
      })

      addListeners(window, 'mousedown touchstart', function (e) {
        if (e.target == chart.canvas) {
          return // let down() handle it
        } else if (e.target.classList.contains("napchartDontLoseFocus")) {
          // hmm we need to make sure keyboard.js's input doesnt auto-blur
          keepAlive = chart.selectedElement
        } else {
          blur(chart)
        }
      })

      // up
      addListeners(window, 'mouseup touchend', function (e) {
        // e.stopPropagation()
        // e.preventDefault()
        up(e, chart)
      })

      // initialize keyboard bindings
      keyboard.init(chart)
    }
  }

  var position // reason for this global var: update() function
  var keepAlive // little hacky: used to preserve keyboard.js focus when clicking outside chart

  function down(e, chart) {
    position = getPosition(e)
    var hit = hitDetect(chart, getCoordinates(position, chart))
    e.stopPropagation()
    e.preventDefault()
    if (Object.keys(hit).length == 0) {
      // if no hit and no pen
      setMousePenLocation(e, chart)
      if (chart.isPen()) {
        penStart(e, chart)
      }
      deselect(chart)
      return
    } else {

      chart.setActive(hit)
      select(chart, hit.elementId)
    }

    update(chart)
  }

  function blur(chart) {
    deselect(chart)
  }

  function penStart(e, chart) {
    // listen and check which way user eventually drags mouse
    setMousePenLocation(e, chart)
    chart.listeningForPenMove = true
  }

  function move(e, chart) {
    var helpers = chart.helpers
    position = getPosition(e)
    var coordinates = getCoordinates(position, chart)

    // first check pen shit
    if (chart.listeningForPenMove) {
      var initialPenLocation = chart.mousePenLocation.minutes
      var info = helpers.XYtoInfo(chart, coordinates.x, coordinates.y)
      var currentLocation = info.minutes

      // scratchDistance is the distance between where you first clicked
      // your pen and how far you have dragged the pen on the surface
      var scratchDistance = helpers.duration(initialPenLocation, currentLocation)

      // the reason for 1430 is that -10 = 1430
      if (scratchDistance > 10 && scratchDistance < 1430) {
        var dragStartOrEnd = (scratchDistance > 720) ? 'start' : 'end'
        var otherStartOrEnd = (dragStartOrEnd == 'end') ? 'start' : 'end'

        var values = {
          lane: chart.mousePenLocation.lane
        };
        values[otherStartOrEnd] = initialPenLocation;
        values[dragStartOrEnd] = snap(currentLocation)

        // check collision
        if (isCollision(chart, values.start, values.end, values.lane)) {
          // ditch
          return
        }

        // create element, make it an activeElement + selected and forget all pen stuff
        var element = chart.createElement(values)

        chart.setActive({
          elementId: element.id,
          type: dragStartOrEnd
        })
        chart.setSelected(element.id)

        chart.listeningForPenMove = false
      } else {
        return
      }
    }

    // add hover
    var hit = hitDetect(chart, coordinates)
    if (Object.keys(hit).length == 0) {
      // if no hit
      // - check if hovers an empty space on lane
      setMousePenLocation(e, chart)
      // - remove hover
      chart.removeHover()
    } else {
      chart.setHover(hit.elementId, hit.type)
    }

    update(chart)
  }

  function up(e, chart) {
    // check if active and
    // delete element if duration == 0
    if (Object.keys(chart.activeElement).length > 0) {
      var id = chart.activeElement.elementId
      var element = chart.data.elements.find(function (e) { return e.id == id; })
      if (helpers.duration(element.start, element.end) == 0) {
        chart.deleteElement(id)
      } else {
        chart.history.add('Move element')
      }
    }

    if (keepAlive) {
      select(chart, keepAlive)
      keepAlive = false
    }

    chart.removeActive()
    chart.listeningForPenMove = false
    chart.onUpdate()
  }

  function setMousePenLocation(e, chart) {
    // sets a variable that is used to mark where an eventual
    // new element will be in pen mode
    position = getPosition(e)
    var coordinates = getCoordinates(position, chart)
    var helpers = chart.helpers

    var info = helpers.XYtoInfo(chart, coordinates.x, coordinates.y)

    if (info.lane == -1) {
      // mouse is not INSIDE a lane
      chart.mousePenLocation = false
    } else {
      // mouse is INSIDE a lane, great!
      chart.mousePenLocation = {
        minutes: snap(info.minutes),
        lane: info.lane
      }
    }
  }

  function update(chart) {
    // first check if there are an activeElement (mouse button down on something)
    // if not bail
    var activeElement = chart.activeElement
    if (Object.keys(activeElement).length > 0) {
      var coordinates = getCoordinates(position, chart)
      var info = helpers.XYtoInfo(chart, coordinates.x, coordinates.y)

      move(activeElement, info)
    }

    function move(hit, info) {
      // clone our element
      var originElement = chart.data.elements.find(function (element) { return element.id == hit.elementId; })
      var changes = {
        // element containig id and changes that should be done
        id: originElement.id
      }

      // do different things based on if you hit a handle (start, end) or the middle of the object
      if (hit.type == 'start' || hit.type == 'end') {
        var minutes = snap(Math.round(info.minutes))

        if (hit.type == 'start') {
          var start = minutes
          var end = originElement.end
        } else {
          var start = originElement.start
          var end = minutes
        }

        var collision = isCollisionStartEnd(chart, start, end, originElement.lane, originElement.id, hit.type)
        if (collision) {
          if (hit.type == 'start') {
            if (helpers.duration(minutes, collision.end) > 720) {
              minutes = end
            } else {
              minutes = collision.end
            }
          } else {
            if (helpers.duration(collision.start, minutes) > 720) {
              minutes = start
            } else {
              minutes = collision.start
            }
          }
        }

        if (originElement[hit.type] != minutes) {
          changes[hit.type] = minutes
        }

        // write changes
        if (Object.keys(changes).length > 1) {
          chart.updateElement(changes)
        }
      } else {
        // hit.type is middle


        var laneIsLocked = chart.getLaneConfig(originElement.lane).locked
        // find lane (only if current != locked)
        if (!laneIsLocked) {
          var distance = info.distance
          var lanes = chart.shape.lanes
          var closestLaneToCursor = lanes.reduce(function (bestLane, thisLane, laneIndex) {
            // distance to lane
            var distanceToLane = Math.abs(distance - (thisLane.start + thisLane.end) / 2)
            if (distanceToLane < bestLane.distanceToLane) {
              return {
                laneIndex: laneIndex,
                distanceToLane: distanceToLane
              }
            }
            return bestLane
          }, {
            distanceToLane: Infinity
          })
          if (closestLaneToCursor.distanceToLane === Infinity) {
            console.error('Could not find a lane to place element in')
          }
          var theLane = closestLaneToCursor.laneIndex

          if (theLane != originElement.lane) { // if changed
            // NB: collision check first
            // is there an element in this lane that obstructs?
            var collision = isCollision(chart, originElement.start, originElement.end, theLane, originElement.id)

            if (!collision) {
              changes.lane = theLane
            }
          }
        }

        // move the bastard
        originElement.duration = helpers.duration(originElement.start, originElement.end)
        var positionInElement = hit.positionInElement
        if (typeof positionInElement === 'undefined') {
          positionInElement = originElement.duration / 2
        }

        var start = snap(helpers.limit(Math.round(info.minutes - positionInElement)))
        var end = helpers.limit(start + originElement.duration)

        // check collision
        var collision = isCollision(chart, start, end, originElement.lane, originElement.id)
        if (collision) {
          // start = collision.end
          // end = start + duration
          var elementsInLane = chart.data.elements.filter(function (element) {
            return (element.lane == collision.lane && // same lane
              element.id != originElement.id) // exclude self
          }).sort(function (a, b) {
            return a.start - b.start
          })

          // where should element be?

          var middlePoint = helpers.limit(info.minutes - positionInElement + originElement.duration / 2)
          // find gaps
          var gapsInLane = elementsInLane.map(function (element, i) {
            if (i == elementsInLane.length - 1) {
              return {
                start: element.end,
                end: elementsInLane[0].start
              }
            } else {
              return {
                start: element.end,
                end: elementsInLane[i + 1].start
              }
            }
          }).map(function (element) { // calculate duration
            element.space = helpers.duration(element.start, element.end)
            return element
          }).filter(function (element) { // remove too small gaps
            return element.space >= originElement.duration
          })

          // which gap element has the endpoint closest to middlePoint?
          var gapElement = gapsInLane.reduce(function (bestGap, currentGap) {
            var d2start = helpers.minutesDistance(currentGap.start, middlePoint)
            var d2end = helpers.minutesDistance(currentGap.end, middlePoint)
            if (d2start < d2end) {
              var startOrEnd = 'start'
              var distance = d2start
            } else {
              var startOrEnd = 'end'
              var distance = d2end
            }
            if (distance < bestGap.distance) {
              return Object.assign({}, currentGap,
                {distance: distance,
                startOrEnd: startOrEnd})
            }
            return bestGap
          }, {
            distance: 1440
          })

          if (gapElement.startOrEnd == 'start') {
            start = gapElement.start
            end = start + helpers.duration(originElement.start, originElement.end)
          } else {
            end = gapElement.end
            start = end - helpers.duration(originElement.start, originElement.end)
          }
        }

        // changes (if it has changed)
        if (originElement.start != start || originElement.end != end) {
          changes.start = helpers.limit(start)
          changes.end = helpers.limit(end)
        }

        if (Object.keys(changes).length === 1) {
          // no changes
          return
        }

        // if locked apply changes on all elements
        if (laneIsLocked) {
          // calculate relative changes instead of absolute
          var relativeChanges = {
            start: changes.start - originElement.start,
            end: changes.end - originElement.end
          }
          var elementsWithThisLane = chart.data.elements.filter(function (e) { return e.lane == originElement.lane; }).map(function (e) { return e.id; })
          chart.updateManyElements(relativeChanges, elementsWithThisLane)
        } else {
          // write changes normal way
          if (Object.keys(changes).length > 1) {
            chart.updateElement(changes)
          }
        }
      }
    }
  }

  // helper functions :
  function isCollision(chart, start, end, lane, id) {
    // returns the element it finds, if not: false
    var found = chart.data.elements.find(function (element) {
      if (id == element.id) {
        // dont check own element
        return false
      }
      return (((helpers.isInside(element.start + 1, start, end) ||
            helpers.isInside(element.end - 1, start, end)) ||
          helpers.isInside(start, element.start + 1, element.end - 1)) && // if element interferes AND...
        element.lane === lane // ...has the lane...
      ) // ... it will send a true and we know that it will be a collision
    })

    if (typeof found === 'undefined') {
      return false
    } else {
      return found
    }
  }

  function isCollisionStartEnd(chart, start, end, lane, id, dragStartOrEnd) {
    // collision detect used when dragging start or end of an element
    var stationaryStartOrEnd = (dragStartOrEnd == 'end') ? 'start' : 'end'

    var collides = chart.data.elements.some(function (element) {
      if (id == element.id) {
        // dont check own element
        return false
      }
      return (((helpers.isInside(element.start + 1, start, end) ||
            helpers.isInside(element.end - 1, start, end)) ||
          helpers.isInside(start, element.start + 1, element.end - 1)) && // if element interferes AND...
        element.lane === lane // ...has the lane...
      ) // ... it will send a true and we know that it will be a collision
    })

    if (!collides) {
      return false
    } else {
      // OK, it *collides*... we know that,
      // now we need to find out where this startorend should be
      // we need to find the first element it would collide with

      // we only need to concentrate about either start or end
      // example dragstartorend = start
      // find the element with a start property closest to
      // our start property in the right direction (for start anticlockwise)
      var ownElement = {
        start: start,
        end: end
      }
      var closestElement = chart.data.elements.reduce(function (bestElement, thisElement) {
        if (id == thisElement.id) {
          // dont check own element
          return bestElement
        }
        var anticlockwise = (dragStartOrEnd == 'start')
        var distance = helpers.range(ownElement[stationaryStartOrEnd], thisElement[stationaryStartOrEnd], anticlockwise)

        if (distance < bestElement.distance) {
          return Object.assign({}, thisElement,
            {distance: distance})
        }
        return bestElement
      }, {
        distance: 1440
      })

      return closestElement
    }
  }

  function getPosition(e) {
    if (typeof e.touches !== 'undefined') {
      return {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      }
    } else {
      return {
        x: e.clientX,
        y: e.clientY
      }
    }
  }

  function getCoordinates(position, chart) {
    var boundingRect = chart.canvas.getBoundingClientRect()
    // use window.devicePixelRatio because if a retina screen, canvas has more pixels
    // than the getCoordinates
    var dpr = typeof window !== 'undefined' ? window.devicePixelRatio : 1
    return {
      x: (position.x - boundingRect.left) * dpr,
      y: (position.y - boundingRect.top) * dpr
    }
  }

  function snap(input) {
    return Math.round(input / 5) * 5
  }

  function select(chart, id) {
    // notify core module:
    chart.setSelected(id)
  }

  function deselect(chart, element) {
    if (typeof element === 'undefined') {
      // deselect all
      chart.deselect()
    }
    // deselect one
    chart.deselect(element)
  }
}

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = function hitDetect (chart, coordinates) {
  var canvas = chart.canvas
  var data = chart.data
  var helpers = chart.helpers

    // will return:
    // element
    // type (start, end, or middle)
    // distance

  var hit = {}

    // hit detection of handles:

  var distance

  data.elements.forEach(function (element) {
    var lane = chart.shape.lanes[element.lane]

      // if element is not selected, continue
    if (!chart.isSelected(element.id)) {
      return
    }
    ['start', 'end'].forEach(function (startOrEnd) {
      var point = helpers.minutesToXY(chart, element[startOrEnd], lane.end)

      distance = helpers.distance(point.x, point.y, coordinates)
      if (distance < chart.config.handlesClickDistance) {
        if (typeof hit.distance === 'undefined' || distance < hit.distance) {
          hit = {
            elementId: element.id,
            type: startOrEnd,
            distance: distance
          }
        }
      }
    })
  })

    // if no handle is hit, check for middle hit

  if (Object.keys(hit).length == 0) {
    var info = helpers.XYtoInfo(chart, coordinates.x, coordinates.y)
    if(!info){
      return {}
    }
    // loop through elements
    data.elements.forEach(function (element) {
      var lane = chart.shape.lanes[element.lane]

        // check if point is inside element horizontally
      if (helpers.isInside(info.minutes, element.start, element.end)) {
          // check if point is inside element vertically
        var innerRadius = lane.start
        var outerRadius = lane.end
        if (info.distance > innerRadius && info.distance < outerRadius) {
          hit = {
            elementId: element.id,
            type: 'middle',
            positionInElement: info.minutes - element.start
          }
        }
      }
    })
  }

  return hit
}


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = {
  init: function (chart) {
    var parent = chart.canvas.parentElement

    var input = document.createElement("input");
    input.style.position = 'absolute';
    input.className = 'hiddenInput';
    input.style.opacity = 0;
    input.style.width = '100px'
    input.style.pointerEvents = 'none';
    input.style.zIndex = 0;
    // hide native blue text cursor on iOS

    input.style.top = '0'

    input.style.left = '0'


    input.type = 'text'

    parent.appendChild(input)

    chart.forceFocusSelected = function () {
      focusSelected(chart.selectedElement)
    }

    chart.onSetSelected = function (selected) {
      if (!selected) {
        input.value = ""
        input.blur()
        return 'get out of here'
      }

      if (!chart.isTouchUser) {
        focusSelected(selected)
      }
    }

    function focusSelected(selected) {
      var selectedElement = chart.data.elements.find(function (e) { return e.id == selected; })
      input.value = selectedElement.text
      input.focus()
      positionInput(input, selectedElement)
      input.oninput = function (e) {
        var value = e.target.value

        chart.updateElement({
          id: chart.selectedElement,
          text: value
        })
      }
    }

    function positionInput(input, element) {
      var helpers = chart.helpers

      var lane = chart.shape.lanes[element.lane]
      var middleMinutes = helpers.middlePoint(element.start, element.end)
      if (helpers.duration(element.start, element.end) < 90) {
        middleMinutes = Math.max(middleMinutes, element.start + 40)
      }

      var radius = lane.end + chart.config.content.textDistance
      if (element.lane == 0) {
        var radius = lane.start - chart.config.content.textDistance
      }

      var textPosition = helpers.minutesToXY(chart, middleMinutes, radius)

      input.value = element.text
    }

    // delete key
    document.onkeydown = function (evt) {
      evt = evt || window.event
      if ((evt.keyCode == 46 || (evt.keyCode == 8 && evt.metaKey)) &&
        chart.selectedElement && input === document.activeElement) {
        chart.deleteElement(chart.selectedElement)
      }
    }
  }
}

/***/ }),
/* 28 */
/***/ (function(module, exports) {

/*
 *  history
 *
 *  This module handles history
 */

module.exports = function (Napchart) {
    var helpers = Napchart.helpers

    Napchart.history = {
        init: function (chart) {
            chart.history = {
                add: function (action) {
                    var history = chart.history

                    var snapshot = JSON.parse(JSON.stringify({
                        elements: chart.data.elements,
                        lanes: chart.data.lanes
                    }))

                    // first check if things have changed
                    if (history.array[history.currentPointer] &&
                        JSON.stringify(history.array[history.currentPointer].snapshot) === JSON.stringify(snapshot)) {
                        // return when no change
                        console.log('no change')
                        return
                    }

                    if (history.currentPointer < history.array.length - 1) {
                        // we are in the middle somewhere, slice off!
                        history.array = history.array.slice(0, history.currentPointer + 1)
                    }
                    history.array.push({
                        action: action,
                        snapshot: snapshot
                    })
                    history.currentPointer = history.array.length - 1

                },

                forward: function (action) {
                    var history = chart.history
                    if (!history.canIGoForward()) {
                        return
                    }
                    history.currentPointer += 1
                    apply(chart, history.array[history.currentPointer].snapshot)

                },
                back: function (action) {
                    var history = chart.history
                    if (!history.canIGoBack()) {
                        return
                    }
                    history.currentPointer -= 1
                    apply(chart, history.array[history.currentPointer].snapshot)

                },

                canIGoForward: function (action) {
                    var history = chart.history
                    if (history.currentPointer < history.array.length - 1) {
                        return history.array[history.currentPointer + 1].action
                    }
                    return null
                },
                canIGoBack: function (action) {
                    var history = chart.history
                    if (history.currentPointer > 0) {
                        return history.array[history.currentPointer].action
                    }
                    return null
                },

                array: [],
                currentPointer: -1
            }
        }
    }

    function apply(chart, s) {
        var snapshot = JSON.parse(JSON.stringify(s))
        chart.data = Object.assign({}, chart.data, snapshot)
        chart.needFullRedraw = true
        Napchart.shape.initShape(chart)
        chart.draw()
    }
}

/***/ })
/******/ ]);
//# sourceMappingURL=napchart.min.js.map